#include <iostream>
#include <sstream>
#include <regex>

using namespace std;

/**
 * This is the script supposed to simulate a GPS gadget with limited amount of memory
 *
 * Reduce mem usage by:
 *    - creating very simple functions (as stupid as possible)
 *    - reusing variables when necessary
 *    - deallocating pointers when done with them
 */


//start of prototypes
int getCRCSPoint(char* a);
bool checkCRC(int* startOfCRC, char* sentence);
bool checkFixQual(char* sentence);
string getLat(char* sentence);
string getLon(char* sentence);
string getAlt(char* sentence);

int main(int argc, char** argv)
{
   //1. check if there are two arguements in input
   if(argc == 2)
   {
      cout << argv[1]<< "\n\n";
      //2. get starting point for checksum
      int tInt1;//first temp integer. Reuse this as much as possible
 
      tInt1 = getCRCSPoint(argv[1]);
      if(tInt1 != -1)//checksum found
      {
         if(checkCRC(&tInt1, argv[1]))
         {
            //3. check if fix quality is either 1 or 2
            if(checkFixQual(argv[1]))
            {
               //4. convert longitude and latitude to human readable form
               string lat = getLat(argv[1]);
               cout << lat << '\n';
               string lon = getLon(argv[1]);
               cout << lon << '\n';
               string alt = getAlt(argv[1]);
               cout << alt << '\n';
            }
            else
            {
               cout << "GGA sentence has an invalid Fix Quality. This might be due to a weak signal or interference\n";
            }
         }
         else
         {
            cout << "GGA sentence appears to have been distorted during transit. This might be due to a weak signal or interference\n";
         } 
      }
   }
   
   return 0;
}

/**
 * This function gets the starting point for the crc in the GGA sentence
 *
 * Returns -1 if begining (*) of checksum is not found
 *
 * @param   char*    argv    the GGA sentence
 *
 * @return  int      returns the index of the first character in the checksum (*) or -1 if first character is not found
 */
int getCRCSPoint(char* argv)
{
   for(int i = 0; argv[i] != '\0'; i++)
   {
      if(argv[i]=='*')
      {
         return i;
      }
   }
   return -1;
}

/**
 * This function GGA sentence with its checksum
 *
 * @param   int*     startOfCRC     The pointer to the index of the first character of the checksum in the GGA sentence
 * @param   char*    sentence       The GGA sentence
 *
 * @return  bool     Returns true if the checksum in the GGA sentence concurs with the one generated by this function from the GGA sentence
 */
bool checkCRC(int* startOfCRC, char* sentence)
{
   //first character of sentence should be $ and the characters after * should be the hex of the checksum
   //delete the first character in the sentence array by moving all characters by one position to the left
   char crc[2];
   for(int i = 1; sentence[i] != '\0'; i++)
   {
      sentence[i-1] = sentence[i];
      if(i == *startOfCRC+1)//check if current character is the first character after '*'
      {
         crc[0]=sentence[i];
         crc[1]=sentence[i+1];
         sentence[i-2] = '\0';
         sentence[i-1] = '\0';
         sentence[i] = '\0';
         sentence[i+1] = '\0';
      }       
   }
   
   //create new crc and compare with that extracted from message
   unsigned int newCRCInt = 0;
   for(int i = 0; sentence[i] != '\0'; i++)
   {
      newCRCInt = newCRCInt ^ sentence[i];
   }
   
   char newCRC[2];
   stringstream ss;
   ss<<hex<<newCRCInt;
   ss>>newCRC;
   
   if(newCRC[0] == crc[0] && newCRC[1] == crc[1])
   {
      //delete[] newCRC;
      //delete[] crc;
      return true;
   }
   else
   {
      //delete[] newCRC;
      //delete[] crc;
      return false;
   }
}

/**
 * This function checks if the fix quality in the sentence is either 1 or 2.
 * If the quality is 0 then the fix is invalid, return false
 *
 * @param   char*    sentence    the GGA sentence
 *
 * @return  bool     returns true if the fix quality is either 1 or 2 and false if the fix quality is 0
 */
bool checkFixQual(char* sentence)
{
   //according to protocol, the fix quality should be after the sixth comma
   int commaNo = 0;
   for(int i = 0; sentence[i] != '\0'; i++)
   {
      if(sentence[i] == ',')
      {
         commaNo++;
         if(commaNo==6)
         {
            if(sentence[i+1]=='0')
            {
               return false;
            }
            else
            {
               return true;
            }
         }
      }
   }
}

/**
 * This function extracts the latitude that is in the form:
 *       llll.ll,a
 *  where:
 *    - the frist two digits are degrees of the latitude 
 *    - the next two digits are the minutes 
 *    - the digits after the . are the minute's mantissa which need to be converted to seconds by multiplying the mantissa by 60
 *    - the hemisphere in which the latitude is
 * 
 * @param   char*    sentence    The GGA sentence
 *
 * @return  string   The Latitude in the form 'Latitude: dd mm' ss" H'. Where H is the character representing the Hemisphere
 */
string getLat(char* sentence)
{
   //GPGGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,x.x,xxxx
   //according to the protocol, latitude is after the second comma
   
   string latDegrees = ""; 
   string latMin = "";
   string latMinMantissa = "0.";
   char latHor;

   int commaNo = 0;
   int latPointPos = -1;
   for(int i = 0; sentence[i] != '\0'; i++)
   {
      if(sentence[i] == ',')
      {
         commaNo++;
         if(commaNo==2)
         {
            latDegrees = sentence[i+1];
            latDegrees = latDegrees + sentence[i+2];

            latMin = sentence[i+3];
            latMin = latMin + sentence[i+4];
         }
         else if(commaNo==3)
         {
            //latMinMantissa[i-latPointPos] = '\0';
            latHor = sentence[i+1];
            break;
         }
      }
      else if(commaNo==2)
      {
         if(sentence[i] == '.')
         {
            latPointPos = i+1;
         }
         else if(latPointPos!=-1)
         {
            latMinMantissa = latMinMantissa + sentence[i];
         }
      }
   }
   
   //convert minute mantissa to seconds by multiplying it with 60
   double sec = ::atof(latMinMantissa.c_str());
   sec = sec * 60;
   int roundedSec = (int)round(sec);
   
   string result = "Latitude: " + latDegrees + "\u00b0 " + latMin + "\' " + to_string(roundedSec) + "\" " + latHor;
   return result;
}

/**
 * This function get the longitude from the GGA sentence that is in the form:
 *    yyyyy.yy,a
 *  Where:
 *    - the first three digits are the degrees of the longitude
 *    - the next two digits are the minutes in the longitude
 *    - the digits after the . are the minutes mantissa
 *    - the character after the comma (,) is the Hemisphere and can either be E or W
 *
 * @param   char*    sentence    The GGA Sentence
 *
 * @return  string   The longitude in the format 'Longitude: dd MM' ss" H'. Where H is the character representing the hemisphere eg E or W
 *
*/
string getLon(char* sentence)
{
   //GPGGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,x.x,xxxx
   //according to the protocol, longitude is after the fourth comma
   
   string lonDegrees = "";
   string lonMin = "";
   string lonMinMantissa = "0.";
   char lonHor;

   int commaNo = 0;
   int lonPointPos = -1;
   for(int i = 0; sentence[i] != '\0'; i++)
   {
      if(sentence[i] == ',')
      {
         commaNo++;
         if(commaNo==4)
         {
            lonDegrees = sentence[i+1];
            lonDegrees = lonDegrees + sentence[i+2];
            lonDegrees = lonDegrees + sentence[i+3];

            lonMin = sentence[i+4];
            lonMin = lonMin + sentence[i+5];
         }
         else if(commaNo==5)
         {
            //latMinMantissa[i-latPointPos] = '\0';
            lonHor = sentence[i+1];
            break;
         }
      }
      else if(commaNo==4)
      {
         if(sentence[i] == '.')
         {
            lonPointPos = i+1;
         }
         else if(lonPointPos!=-1)
         {
            lonMinMantissa = lonMinMantissa + sentence[i];
         }
      }
   }
   
   //convert minute mantissa to seconds by multiplying it with 60
   double sec = ::atof(lonMinMantissa.c_str());
   sec = sec * 60;
   int roundedSec = (int)round(sec);
   
   string result = "Longitude: " + lonDegrees + "\u00b0 " + lonMin + "\' " + to_string(roundedSec) + "\" " + lonHor;
   return result;
}


/**
 * This function gets the altitude of the reading in the sentence that is in the for 
 *    x.x,M
 * where:
 *    - the first digits make up the altitude
 *    - the character after the comma is the units for the altitude where M means Metres
 *
 * @param   char*    sentence    The GGA sentence
 *
 * @return  string   the altitude in the form 'Altitude: x.x M'. Where M is the units
*/
string getAlt(char* sentence)
{
   //according the the protocol, the reading's altitude appears after the ninth comma
   //GPGGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,x.x,xxxx
   string altitude = "";
   char altUnits;   

   int commaNo = 0;
   for(int i = 0; sentence[i] != '\0'; i++)
   {
      if(sentence[i] == ',')
      {
         commaNo++;
         if(commaNo == 10)
         {
            altUnits = sentence[i+1];
            break;
         }
      }
      else if(commaNo == 9)
      {
         altitude = altitude + sentence[i];
      }
   }
   
   string result = "Altitude: " + altitude + " " + altUnits;
   return result;
}
